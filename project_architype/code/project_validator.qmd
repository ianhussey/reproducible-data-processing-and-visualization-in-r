---
title: "Repository Compliance Check"
format:
  html:
    toc: true
    code-fold: true
execute:
  echo: false
  warning: false
  message: false
---

```{r}
#| label: setup
# Packages (install if needed)
needed <- c("fs","dplyr","stringr","purrr","tibble","readr")
to_install <- setdiff(needed, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, quiet = TRUE)
invisible(lapply(needed, library, character.only = TRUE))

```

```{r}

project_root <- fs::path_abs("../")
all_paths <- fs::dir_ls(project_root, recurse = TRUE, type = "any", fail = FALSE, all = TRUE)

# Helper to create a test row
mk_test <- function(test, passed, details = "") {
  tibble::tibble(test = test, status = ifelse(passed, "PASS", "FAIL"), details = details)
}

# Helper: case-insensitive file existence relative to root
exists_ci <- function(relpath) {
  # Accepts a single path like "readme.md"
  parts <- fs::path_split(relpath)[[1]]
  cur <- project_root
  for (p in parts) {
    cand <- fs::dir_ls(cur, type = "any", recurse = FALSE, fail = FALSE, all = TRUE)
    # match ignoring case
    hit <- cand[tolower(fs::path_file(cand)) == tolower(p)]
    if (length(hit) == 0) return(FALSE)
    cur <- hit[[1]]
  }
  TRUE
}

# Helper: list files by extension (case-insensitive)
list_ext <- function(ext) {
  # ext without dot, e.g., "png"
  ix <- tolower(fs::path_ext(all_paths)) == tolower(ext)
  all_paths[ix & fs::is_file(all_paths)]
}

# Helper: path starts with any of allowed prefixes (relative to root)
starts_with_any <- function(paths, allowed_dirs_rel) {
  allowed_abs <- fs::path_abs(fs::path(project_root, allowed_dirs_rel))
  # Normalize to absolute for comparison
  purrr::map_lgl(paths, function(p) {
    # directory of file p
    pd <- fs::path_dir(p)
    any(startsWith(pd, allowed_abs))
  })
}

results <- tibble::tibble(test = character(), status = character(), details = character())

## 1) Required directories (must exist)
required_dirs <- c("code", "data", "data/raw", "data/processed")
for (d in required_dirs) {
  exists_dir <- fs::dir_exists(fs::path(project_root, d))
  results <- dplyr::bind_rows(results, mk_test(
    paste0("Directory exists: ", d),
    exists_dir,
    if (!exists_dir) "Create this directory." else ""
  ))
}

## 2) Required files (must exist)
# You asked for "readme.md" and "LICENSE".
# The example repo shows "readme.md" and "LICENSE".
# We'll accept either spelling for the license and flag the naming.
readme_ok <- exists_ci("readme.md")
license_any_ok <- exists_ci("licence") || exists_ci("license") || exists_ci("LICENSE")

results <- dplyr::bind_rows(
  results,
  mk_test('File exists: readme.md', readme_ok, if (!readme_ok) "Add a README (readme.md)." else ""),
  mk_test('File exists: licence/license', license_any_ok,
          if (!license_any_ok) "Add a licence file (prefer `LICENSE`)." else "")
)

# If both exist but name is not canonical "LICENSE", suggest normalising
license_paths <- all_paths[str_to_lower(fs::path_file(all_paths)) %in% c("licence","license","license.txt","licence.txt","license.md","licence.md","license.rst","licence.rst","license") ]
if (length(license_paths) > 0) {
  canonical <- any(fs::path_file(license_paths) == "LICENSE")
  results <- dplyr::bind_rows(
    results,
    mk_test("License name is canonical (LICENSE)", canonical,
            if (!canonical) "Consider renaming to `LICENSE` (all caps, no extension)." else "")
  )
}

## 3) Inferred filetype-location constraints (from your structure)
# From the provided tree we infer:
# - .png only under code/plots 
# - .rds only under code/models 
# - .qmd, .Rmd, .R only under code/ 
# - .csv only under data/processed, data/raw, data/results 
# - .xlsx only under data/processed and data/raw 
# - .html only under code/ or methods/ 

constraints <- list(
  png  = list(must_be_in = c("code/plots"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  rds  = list(must_be_in = c("code/models"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  qmd  = list(must_be_in = c("code"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  Rmd  = list(must_be_in = c("code"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  R    = list(must_be_in = c("code"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  csv  = list(must_be_in = c("data/processed","data/raw","data/results"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE),
  xlsx = list(must_be_in = c("data/processed","data/raw"), must_exist_in_each = FALSE, forbidden_elsewhere = TRUE)
)

# Additionally restrict html to code/ or methods/
html_files <- list_ext("html")
if (length(html_files)) {
  allowed_dirs <- c("code", "methods")
  html_ok <- all(starts_with_any(html_files, allowed_dirs))
  offenders <- character(0)
  if (!html_ok) {
    offenders <- fs::path_rel(
      html_files[!starts_with_any(html_files, allowed_dirs)],
      start = project_root
    )
  }
  results <- dplyr::bind_rows(
    results,
    mk_test(
      "All .html files are under code/ or methods/",
      html_ok,
      if (!html_ok)
        paste0("Move .html files to code/ or methods/. Offenders: ",
               paste(offenders, collapse = "; "))
      else ""
    )
  )
}

check_constraint <- function(rule, ext) {
  files <- list_ext(ext)
  rel <- fs::path_rel(files, start = project_root)

  # 3a) Required presence in specific dirs
  if (isTRUE(rule$must_exist_in_each) && length(rule$must_be_in) > 0) {
    for (dir_req in rule$must_be_in) {
      under_dir <- files[starts_with_any(files, dir_req)]
      results <<- dplyr::bind_rows(results, mk_test(
        paste0("At least one .", ext, " in ", dir_req),
        length(under_dir) > 0,
        if (length(under_dir) == 0) paste0("Add a .", ext, " file under ", dir_req, ".") else ""
      ))
    }
  }

  # 3b) Forbidden elsewhere
  if (isTRUE(rule$forbidden_elsewhere)) {
    if (length(files)) {
      allowed_ok <- if (length(rule$must_be_in) == 0) {
        length(files) == 0
      } else {
        all(starts_with_any(files, rule$must_be_in))
      }
      offenders <- character(0)
      if (!allowed_ok && length(files)) {
        allowed_mask <- starts_with_any(files, rule$must_be_in)
        offenders <- fs::path_rel(files[!allowed_mask], start = project_root)
      }
      results <<- dplyr::bind_rows(results, mk_test(
        paste0("All .", ext,
               if (length(rule$must_be_in)) paste0(" files reside in ", paste(rule$must_be_in, collapse = ", "))
               else " files are absent"),
        allowed_ok,
        if (!allowed_ok) paste0("Move/remove: ", paste(offenders, collapse = "; ")) else ""
      ))
    } else if (isFALSE(rule$must_exist_in_each)) {
      results <<- dplyr::bind_rows(results, mk_test(
        paste0("No .", ext, " files present (as expected)"),
        TRUE, ""
      ))
    }
  }
}

purrr::iwalk(constraints, check_constraint)

## 4) Optional hygiene checks (toggle as needed)
enable_hygiene <- TRUE

if (enable_hygiene) {
  # No data files under code/ (except .rds under code/models already allowed)
  data_exts <- c("csv","xlsx","tsv","sav","dta","parquet","feather","rds")
  under_code <- all_paths[startsWith(fs::path_dir(all_paths), fs::path(project_root, "code")) & fs::is_file(all_paths)]
  offenders <- under_code[tolower(fs::path_ext(under_code)) %in% data_exts &
                            !starts_with_any(under_code, "code/models")]
  results <- dplyr::bind_rows(results, mk_test(
    "No data files stored under code/ (except rds in code/models)",
    length(offenders) == 0,
    if (length(offenders)) paste0("Move: ", paste(fs::path_rel(offenders, start = project_root), collapse = "; ")) else ""
  ))

  # .html only in code/ or methods/ already checked above

  # Presence of .gitignore with sensible entries
  has_gitignore <- exists_ci(".gitignore")
  results <- dplyr::bind_rows(results, mk_test(
    "Has .gitignore",
    has_gitignore,
    if (!has_gitignore) "Add a .gitignore (e.g., ignore .Rhistory, .RData, .Rproj.user, cache, large tmp files)." else ""
  ))

  # # Flag very large files (>50MB) (encourage Git LFS)
  # sizes <- tryCatch(fs::file_info(all_paths), error = function(e) NULL)
  # large <- dplyr::filter(sizes, type == "file", size >= units::set_units(50, "MB"))
  # if (nrow(large)) {
  #   large_offenders <- large$path[!starts_with_any(large$path, c("communications","methods","preregistration"))]
  #   results <- dplyr::bind_rows(results, mk_test(
  #     "No large binary files (>50MB) outside communications/methods/preregistration",
  #     length(large_offenders) == 0,
  #     if (length(large_offenders)) paste0("Consider Git LFS or relocating: ",
  #                                         paste(fs::path_rel(large_offenders, start = project_root), collapse = "; ")) else ""
  #   ))
  # } else {
  #   results <- dplyr::bind_rows(results, mk_test(
  #     "No large binary files (>50MB) outside communications/methods/preregistration",
  #     TRUE, ""
  #   ))
  # }

  # Filename hygiene: spaces discouraged
  bad_names <- fs::path_file(all_paths[fs::is_file(all_paths) & str_detect(fs::path_file(all_paths), "\\s")])
  results <- dplyr::bind_rows(results, mk_test(
    "No spaces in filenames",
    length(bad_names) == 0,
    if (length(bad_names)) paste0("Rename: ", paste(bad_names, collapse = "; ")) else ""
  ))
}

## 5) Present results
results <- results |>
  mutate(status = factor(status, levels = c("PASS","FAIL"))) |>
  arrange(desc(status), test)

n_fail <- sum(results$status == "FAIL")
n_pass <- sum(results$status == "PASS")

cat(sprintf("** %d PASS / %d FAIL **\n\n", n_pass, n_fail))
if (n_fail > 0) {
  cat("Address the FAILED items below.\n")
} else {
  cat("All checks passed.\n")
}

results |>
  mutate(details = ifelse(details == "", "-", details)) |>
  dplyr::rename(`Test` = test, `Status` = status, `Details / Guidance` = details) |>
  knitr::kable()

```
