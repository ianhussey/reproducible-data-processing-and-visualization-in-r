---
title: "Data transformation I: {dplyr}'s `select()`, `filter()` and `mutate()`" 
format: 
  html: 
    toc: true 
    toc_float: true 
    code-fold: show 
    code-tools: true 
---

```{r}
#| include: false

# settings, placed in a chunk that will not show in the .html file (because include=FALSE) 

# disables scientific notation so that small numbers appear as eg "0.00001" rather than "1e-05"
options(scipen = 999)  

```

The next few chapters cover various {tidyverse} functions - sometimes called verbs - that are used for data transformation.

This chapter covers functions that are "*non-aggregating*": they allow you to change which columns or rows are present in the dataset, to create new columns or split up existing ones, to change their contents, etc. `rename()`, which you learned in the previous chapter, is one of these functions.

## Keeping or dropping columns with `dplyr::select()`

Not all columns in a dataset are useful to us. When processing data, we often wish to keep only some columns and drop others. We can do this with `dplyr::select()`.

We'll start where the last chapter ended, by loading dependencies, reading in the 'data_demographics_raw_messy.csv' dataset, and renaming the columns to make them easier to work with.

```{r}
library(readr) # for read_csv()
library(janitor) # for clean_names()
library(dplyr) # for %>%
library(knitr) # for kable()
library(kableExtra) # for kable_extra()

dat_demographics_renamed <- 
  read_csv(file = "../data/raw/data_demographics_raw_messy.csv",
           skip = 2) %>%
  clean_names() %>%
  rename(id = subject_code, 
         block_trial = block_code_and_trial_number, 
         question = trial_code, 
         response = key_response_use_this, 
         rt = x0_ms_onset_rt)

dat_demographics_renamed %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

If our data processing goal is to extract and tidy responses on the demographics questionnaire, we only need some of these columns: id, question, and response. We can use `select()` and the pipe to retain only these.

```{r}
dat_demographics_selected <- dat_demographics_renamed %>%
  select(id, 
         question, 
         response)

dat_demographics_selected %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

What code would you write to select the 'date' and 'correct' columns?

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_demographics_selected <- dat_demographics_renamed %>%
  select(date, 
         correct)
```
:::

What code would you write to print all the columns present in 'dat_demographics_renamed' in a way you can easily paste into a `select()` call? This was covered in [the previous chapter](the_pipe_and_renaming.qmd).

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_demographics_renamed %>%
  colnames() %>%
  dput()
```
:::

### Positive vs. negative selections

The above example tells `select()` the columns to retain. You could instead tell it which ones to drop. This is a negative selection: you preface the column name with `-`.

```{r}
dat_demographics_selected <- dat_demographics_renamed %>%
  select(-date, 
         -build, 
         -block_trial, 
         -correct, 
         -rt)

dat_demographics_selected %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

It's tempting to think in terms of negative selections, i.e., getting rid of columns you don't want. However, you should in general use positive selections and avoid negative ones. If the underlying data changes in some way, e.g., in a prior processing step, it can contain variables your negative selection doesn't account for. For example, if 'dat_demographics_renamed' now included another column, "completed_study" (TRUE/FALSE), the positive selection would not include this variable as it wasn't listed, but the negative selection would as it was not specifically excluded. This can produce code that is more 'fragile' to changes in the data.

In general, tell select what you *do want*, not what you *don't want*.

Check your understanding of positive and negative selections: What would happen if you mix positive and negative selections?

1.  What columns will be present in the output when your run the code below?

```{r}
#| eval: false
dat_demographics_selected <- dat_demographics_renamed %>%
  select(id, 
         question, 
         response,
         -correct)

dat_demographics_selected %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
#| include: false
dat_demographics_selected <- dat_demographics_renamed %>%
  select(id, 
         question, 
         response,
         -correct)

dat_demographics_selected %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```
:::

Why are those columns present and not others?

::: {.callout-note collapse="true" title="Click to show answer"}
Once positive selections are present in the select call, the negative ones are redundant. You've already told `select()` what to include, which implies what not to include.
:::

### {tidyselect} helper functions

Often, we have large datasets with many columns. `select()` calls can be made simpler with the help of another {tidyverse} package, {tidyselect}.

To illustrate this, we'll use a simulated dataset called 'dat_many_columns' that contains, you guessed it, many columns.

```{r}
#| include: false # don't show code in the ebook

# this block simulates a dataset with many columns using the {truffle} package

# install the packages devtools and truffles if not already installed 
if (!requireNamespace("stringr", quietly = TRUE)) {
  install.packages("stringr")
}
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}
if (!requireNamespace("truffle", quietly = TRUE)) {
  devtools::install_github("ianhussey/truffle")
}

library(truffle)
library(stringr)

dat_many_columns <-
  truffle_likert(n_per_condition = 5,
                 factors  = c("X1_latent", "X2_latent", "X3_latent"),
                 prefixes = c("X1_item", "X2_item", "X3_item"),
                 alpha = c(.70, .75, .80),
                 n_items = c(10, 7, 15),
                 n_levels = 7,
                 r_among_outcomes = 0.50,
                 approx_d_between_groups = c(0.50, 0.20, 1.00),
                 seed = 42) %>% 
  truffle_demographics() %>%
  rename_with(~ str_replace_all(.x, "X", "depression_scale"))
```

Let's start by printing the column names:

```{r}
dat_many_columns %>%
  colnames() %>%
  dput()
```

**Exercise**

Write code to:

1.  Create a new data frame called 'dat_fewer_columns'
2.  `select()` all the columns beginning with "depression", using only positive selections
3.  Print the column names to confirm that these are the only ones present

```{r}
#| include: false











```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_fewer_columns <- dat_many_columns %>%
  select(depression_scale1_item1, 
         depression_scale1_item2, 
         depression_scale1_item3, 
         depression_scale1_item4, 
         depression_scale1_item5, 
         depression_scale1_item6, 
         depression_scale1_item7, 
         depression_scale1_item8, 
         depression_scale1_item9, 
         depression_scale1_item10, 
         depression_scale2_item1, 
         depression_scale2_item2, 
         depression_scale2_item3, 
         depression_scale2_item4, 
         depression_scale2_item5, 
         depression_scale2_item6, 
         depression_scale2_item7, 
         depression_scale3_item1, 
         depression_scale3_item2, 
         depression_scale3_item3, 
         depression_scale3_item4, 
         depression_scale3_item5, 
         depression_scale3_item6, 
         depression_scale3_item7, 
         depression_scale3_item8, 
         depression_scale3_item9, 
         depression_scale3_item10, 
         depression_scale3_item11, 
         depression_scale3_item12, 
         depression_scale3_item13, 
         depression_scale3_item14, 
         depression_scale3_item15)

dat_fewer_columns %>%
  colnames() %>%
  dput()
```
:::

This can be done more easily with `tidyselect::starts_with()`:

```{r}
library(tidyselect)

dat_fewer_columns <- dat_many_columns %>%
  select(starts_with("depression"))

dat_fewer_columns %>%
  colnames() %>%
  dput()
```

There are many other {tidyselect} helper functions including:

-   `starts_with()` : Selects columns ending in a character string
-   `ends_with()` : Selects columns ending in a character string
-   `contains()` : Selects columns containing a character string, not necessarily at the start or end
-   `all_of()` : Selects all of the column names in a vector e.g., `all_of(c("a", "b"))`
-   `any_of()` : Selects any of the column names in a vector that are present, silently dropping missing ones. This can be very useful when columns may or may not be present, but has the risk of creating silent errors.
-   `where()` : Select columns that meet a criterion, e.g., `where(is.numeric)` selects only columns containing numeric data.
-   `everything()` : This will seem redundant right now, but will become useful later on when we cover `pivot_` functions

**Exercise**

Write code to select all columns for scale 2.

```{r}
#| include: false

# dat_fewer_columns <- dat_many_columns %>%









```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_fewer_columns <- dat_many_columns %>%
  select(contains("scale2"))

dat_fewer_columns %>%
  colnames() %>%
  dput()
```
:::

**Exercise**

Write code to select from the 'dat_many_columns' data frame the "id", "age" and "gender" columns AND all columns related to item3.

```{r}
#| include: false

# dat_fewer_columns <- dat_many_columns %>%









```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_fewer_columns <- dat_many_columns %>%
  select(id, age, gender, contains("item3"))

dat_fewer_columns %>%
  colnames() %>%
  dput()
```
:::

**Exercise**

Write code to select the "id", "age" and "gender" columns AND all columns related to item1.

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_fewer_columns <- dat_many_columns %>%
  select(id, age, gender, ends_with("item1"))

dat_fewer_columns %>%
  colnames() %>%
  dput()
```
:::

### Selection with set operations

Negative selection using `-` is selection using a "set operation" or a set of logical rules that determine which column names are in the selected set. There are others:

-   Set operations:
    -   `-` negative selection
    -   `c()` : combine selections
    -   `!` invert selection
    -   `&` must meet both selection rules
    -   `|` can meet either selection criteria

For example: select columns that refer to scale 3 AND items \>=10:

```{r}
dat_fewer_columns <- dat_many_columns %>%
  select(id, age, gender, 
         # items containing scale3 AND item1 but NOT item 1
         c(contains("scale3") & contains("item1") & !ends_with("item1")))

dat_fewer_columns %>%
  colnames() %>%
  dput()
```

**Exercise**

To practice {tidyselect} helpers and selection set operations, write code in a creative and unnecessarily complex way to select the columns "id", "gender", and "age", and the items from scale 1 and scale 3 that whose items are \<= 10.

Note: no solution provided here as many different ones are possible.

```{r}
#| include: false








```

### Practicing select and the pipe in a longer chunk

**Exercise**

The first chunk in this chapter read in the 'data_demographics_raw_messy.csv' file and renamed columns.

-   Rewrite that chunk here - as much as possible from memory, without simply copy pasting.
-   Add another pipe and selecting the "id", "question" and "response" columns.
-   Print a table of the resulting data frame using `kable()` and `kable_class()`

Note: no solution provided here to reduce the temptation to peek or copy-paste.

```{r}
#| include: false








```

## Moving columns with `dplyr::relocate()`

You can reorder to columns within a data frame with `relocate()`.

Unlike `rename()`, `select()`, and other functions, only one column can be relocated with each `relocate()` call.

You can relocate columns before or after others, or to locations such as being the first or last column. This code moves the "response" column to be before the "question" column, and the "correct" column to be the last one.

```{r}
dat_demographics_renamed %>%
  relocate(response, .before = "question") %>%
  relocate(correct, .after = last_col()) %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

**Exercise**

What code is needed to relocate the columns of 'dat_demographics_renamed' so that they are in the order "id", "question", "response", and then the remaining columns.

```{r}
#| include: false

# dat_demographics_reordered <- dat_demographics_renamed %>%








```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_demographics_reordered <- dat_demographics_renamed %>%
  relocate(id, .before = 1) %>% 
  relocate(question, .after = "id") %>%
  relocate(response, .after = "question")

dat_demographics_reordered %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```
:::

**Exercise**

All three of the solutions below accomplish the goal of making the "id" column the first column:

```{r}
# move "id" to be the first column by placing it before "date"
dat_demographics_renamed %>%
  relocate(id, .before = "date") %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)

# move "date" to be the second column by placing it after "id", producing the same result
dat_demographics_renamed %>%
  relocate(date, .after = "id") %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)

# move "id" to be the 1st column by placing it before the first column by location, producing the same result
dat_demographics_renamed %>%
  relocate(id, .before = 1) %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

Which of the above solutions is the least 'fragile' solution, i.e., that is robust to changes in the data or elsewhere in your data processing code?

::: {.callout-note collapse="true" title="Click to show answer"}
`relocate(id, .before = 1)` does not rely on the name and location of another column and is therefore the least fragile solution.
:::

## Renaming, relocating, and selecting all-in-one with `select()`

Renaming, relocating, and selecting columns are so common as a set of three tasks that you can do it all within `select()`.

Whatever order columns appear in `select()` they will be relocated to. You can rename variables inside select just as you do in `rename()` using `new_name = old_name`.

```{r}
dat_demographics_renamed %>%
  select(id, date, question, answer = response) %>%
  head() %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

## Keeping or dropping rows with `dplyr::filter()`

Not all rows in a dataset are useful to us. When processing data, we often wish to keep only some rows and drop others. We can do this with `dplyr::filter()`.

It is important to learn the difference between `select()` and `filter()`, it is initially confusing.

-   `select()` keeps or drops **columns**
-   `filter()` keeps or drops **rows**

For example, filter the 'question' column to contain only "age" items:

```{r}
dat_filtered_age <- dat_demographics_renamed %>%
  filter(question == "age")

dat_filtered_age %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

**Exercise**

Write code to:

-   Take the 'dat_demographics_renamed' data frame
-   Create two data frames called 'dat_filtered_age' and 'dat_filtered_gender'
-   Retain only the relevant rows of 'question' for each.
-   Rename the 'response' columns to what variable it now contains.
-   Drop the 'question' columns since they're now irrelevant.
-   Print a table of each data frame.

```{r}
#| include: false










```

::: {.callout-note collapse="true" title="Click to show answer"}
```{r}
dat_filtered_age <- dat_demographics_renamed %>%
  filter(question == "age") %>%
  rename(age = response) %>%
  select(-question)

dat_filtered_age %>%
  kable() %>%
  kable_classic(full_width = FALSE)


dat_filtered_gender <- dat_demographics_renamed %>%
  filter(question == "gender") %>%
  rename(gender = response) %>%
  select(-question)

dat_filtered_gender %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```
:::

### Filters with set operations

You can specify the logical test for filtering in many ways, including:

-   `==` : 'is exactly equal to this one value'
-   `%in%` : 'is exactly equal to one of the following values':
-   `!=` : 'is not exactly equal to

Note that equivalence is two equals signs (`==`) whereas setting arguments in functions is one (`=`).

Weirdly, there is no single function that provides the combination of `%in%` and `!=`, i.e., 'is not exactly equal to any of the following values'. This can be achieved with the (relatively unintuitive) `dat %>% filter(!column_name %in% c('value1', 'value2', 'value3'))`.

Just as with `select()`, it is often better to define what you *do* want (`==` and `%>%`) rather than what you *do not* want (`!=`). This is even more important with `filter()` as unexpected row values are much more common than unexpected column names.

You can also combine multiple tests with various operators:

- `&` : AND, i.e., meeting both criterion. 
- `|` : OR, i.e., meeting either criterion. 

For example, `dat %>% filter(gender == "male" & age == 22)` returns participants whose gender is set to "male" and age is 22. 

In contrast, `dat %>% filter(gender == "male" | age == 22)` returns participants whose gender is set to "male" or their age is 22. Female participants aged 22 will be returned, as will male participants aged 26 etc. Another example: `dat %>% filter(gender == "male" | gender == "female)` returns participants whose gender is set to "male" or "female" but not other responses or NA.

### Positive vs. negative filters

For example, if you specify a negative filter `dat %>% filter(gender != "non-binary)"` because you wish to filter to return only participants who identify as 'male' or 'female', you have in fact only excluded participants who specified 'non-binary'. This code would also return participants with other response options such as 'non binary', 'Non-Binary', 'NB', etc.

However, there can be cases where you specifically do not want some rows or want to retain anything other than a given value. Protecting participant privacy is one of them.

Some rows of the 'dat_demographics_renamed' data frame contain "prolific ID" values, which could be linked back to the individual's Prolific.com account where they completed the study, and therefore risk exposing identifying information. If this data was shared with other researchers or publicly, this could violate the informed consent agreement and/or local data privacy laws. (Note that the prolific IDs included in this data frame are made up.) This is discussed in more detail in the chapter on [Data Privacy](privacy.qmd).

In this case, you would likely need to remove all rows referring to Prolific ID with a negative filter:

```{r}
dat_demographics_anonymized <- dat_demographics_renamed %>%
  filter(question != "prolific ID")
  
dat_demographics_anonymized %>%
  kable() %>%
  kable_classic(full_width = FALSE)
```

Note that the original 'data_demographics_raw_messy.csv' data file we originally read in to R still contains the Prolific ID codes! Again, see the [Data Privacy](privacy.qmd) chapter for how you would deal with this more thoroughly in your own projects.

## Creating and altering columns with `dplyr::mutate()`

### Understanding `mutate()`

`mutate()` is used to create new columns or to change the contents of existing ones.

```{r}

# mutating new variables
example_1 <- data_amp_test_trials %>%
  mutate(latency_plus_1 = rt_ms + 1)

example_2 <- data_amp_test_trials %>%
  mutate(log_latency = log(rt_ms))

# mutating the contents of existing variables
example_3 <- data_amp_test_trials %>%
  mutate(rt_s = rt_ms / 1000) # latency is now in seconds rather than milliseconds

```

The operations inside mutate can range from the very simple, like the above, to much more complex. The below example uses other functions we haven't learned yet. For now, just notice that there can be multiple mutate calls and they can produce a cleaned up gender variable.

```{r}

# illustrate the problem with the gender responses:
data_demographics_trimmed %>%
  # filter only the gender item, not age
  filter(item == "gender") %>%
  count(response) %>%
  arrange(desc(n))

# clean up the gender variable
data_demographics_gender_tidy_1 <- data_demographics_trimmed %>%
  # filter only the gender item, not age
  filter(item == "gender") %>%
  # change the name of the response variable to what it now represents: gender
  rename(gender = response) %>%
  # change or remove weird responses to the gender question
  mutate(gender = str_to_lower(gender)) %>%
  mutate(gender = str_remove_all(gender, "[\\d.]")) %>% # remove everything except letters
  mutate(gender = na_if(gender, "")) %>% 
  mutate(gender = case_when(gender == "woman" ~ "female",
                            gender == "man" ~ "male",
                            gender == "girl" ~ "female",
                            gender == "yes" ~ NA_character_,
                            gender == "dude" ~ "male",
                            gender == "non binary" ~ "non-binary",
                            TRUE ~ gender)) %>%
  # select only the columns of interest
  select(unique_id, gender)

# illustrate the data after cleaning:
data_demographics_gender_tidy_1 %>%
  count(gender) %>%
  arrange(desc(n))

```

A single mutate call can contain multiple mutates. The code from the last chunk could be written more simply like this:

```{r}

# clean up the gender variable
data_demographics_gender_tidy_2 <- data_demographics_trimmed %>%
  # filter only the gender item, not age
  filter(item == "gender") %>%
  # change the name of the response variable to what it now represents: gender
  rename(gender = response) %>%
  # change or remove weird responses to the gender question
  mutate(gender = str_to_lower(gender),
         gender = str_remove_all(gender, "[\\d.]"), # remove everything except letters
         gender = na_if(gender, ""), 
         gender = case_when(gender == "woman" ~ "female",
                            gender == "man" ~ "male",
                            gender == "girl" ~ "female",
                            gender == "yes" ~ NA_character_,
                            gender == "dude" ~ "male",
                            gender == "non binary" ~ "non-binary",
                            TRUE ~ gender)) %>%
  # select only the columns of interest
  select(unique_id, gender)

# check they are identical
identical(data_demographics_gender_tidy_1, data_demographics_gender_tidy_2)

```

### Practice `mutate()`

When analyzing cognitive behavioral tasks, it is common to employ mastery criteria to exclude participants who have not met or maintained some criterion within the task. We'll do the actual exclusions etc. later on, but for practice using `mutate()` by creating a new `fast_trial` column to indicate trials where the response was implausibly fast (e.g., \< 100 ms).

Try doing this with a simple logical test of whether latency \< 100. You can do this with or without using the `ifelse()` function.

```{r}

data_amp_test_trials_with_fast_trials <- data_amp_test_trials %>%
  mutate(fast_trial = ifelse(test = rt_ms < 100,
                             yes = TRUE,
                             no = FALSE))

# more briefly but less explicitly
data_amp_test_trials_with_fast_trials <- data_amp_test_trials %>%
  mutate(fast_trial = rt_ms < 100)

```

### Conditionals with `ifelse()`

Use `mutate()` to remove weird values from `data_demographics_trimmed$response`, for the rows referring to age, that aren't numbers.

What function could you use to first determine what values are present in this column, to know which could be retained or changed?

In simple cases like this, you can use `mutate()` and `ifelse()` to change impossible values to `NA`.

```{r}

# what values are present?
data_demographics_trimmed %>%
  filter(item == "age") %>%
  count(response) 

# fix them with mutate
data_demographics_age_tidy <- data_demographics_trimmed %>%
  filter(item == "age") %>%
  mutate(response = ifelse(test = response == "old",
                           yes = NA_integer_,
                           no = response)) %>%
  mutate(response = as.numeric(response)) %>%
  rename(age = response)

# check this has fixed the issue
data_demographics_age_tidy %>%
  count(age)

```

### Practice `mutate()` & `ifelse()`

Use `mutate()` to remove weird values from `data_selfreport_trials$response` that aren't Likert responses.

First determine what values are present in this column.

Use `ifelse()` and `%in%` inside `mutate()` to change values other than the Likert responses to `NA`.

**If you struggle to do this: practice writing 'pseudocode' here. That is, without knowing the right code, explain in precise logic what you want the computer to do. This can be converted to R more easily.**

```{r}

# what values are present?
data_selfreport_trials %>%
  count(response)

# what type of data is the response column?
class(data_selfreport_trials$response)

# remove non Likert values
data_selfreport_tidy <- data_selfreport_trials %>%
  mutate(response = ifelse(response == "Ctrl+'B'", NA_integer_, response),
         response = as.numeric(response))


# show the data after changes
data_selfreport_tidy %>%
  count(response)

class(data_selfreport_tidy$response)

```

What other ways are there of implementing this mutate, e.g., without using `%in%`? What are the pros and cons of each?

```{r}

# write examples here

```

### Multiple logical conditions with `case_when()` and `case_match()`

TODO

`case_when()` allows you to compare multiple logical tests or if-else tests.



## Exercises

### `select()` vs. `filter()`

What is the difference between select and filter?

::: {.callout-note collapse="true" title="Click to show answer"}
`select()` is for columns, `filter()` is for rows.
:::

### {tidyselect} helper functions

TODO

### Positive vs. negative selections and filters

TODO

### Set operators 

What set operators can be used with `select()` and how?

TODO

What set operators can be used with `filter()` and how?

TODO

### Interactive exercises

Complete the interactive exercises for:

- [`select()`](https://errors.shinyapps.io/dplyr-learnr/#section-dplyrselect)
- [`relocate()`](https://errors.shinyapps.io/dplyr-learnr/#section-dplyrrelocate) 
- [`filter()`](https://errors.shinyapps.io/dplyr-learnr/#section-dplyrfilter) 
- [`mutate()`](https://errors.shinyapps.io/dplyr-learnr/#section-dplyrmutate) 
- [`case_when()`](https://errors.shinyapps.io/dplyr-learnr/#section-dplyrcase_when) 

### ??

In your local version of this .qmd file, TODO

```{r}
#| include: false



```

### Practice `mutate()` & `case_when()`

TODO

The AMP data needs to be reverse scored. Just like an item on a self-report that is worded negatively (e.g., most items: I am a good person; some items: I am a bad person), the negative prime trials have the opposite 'accuracy' values that they should. Use `mutate()` and `case_when()` to reverse score the negative prime trials, so that what was 0 is now 1 and what was 1 is now 0.

```{r}

# in your own time later, see if you can rewrite this yourself without looking at the answer to practice using case_when
data_amp_tidy <- data_amp_test_trials_with_fast_trials %>%
  mutate(correct = case_when(trial_type == "prime_positive" ~ correct,
                             trial_type == "prime_negative" & correct == 0 ~ 1,
                             trial_type == "prime_negative" & correct == 1 ~ 0))

# you can also specify a default value to return if none of the logical tests are passed with 'TRUE ~':
data_amp_tidy <- data_amp_test_trials_with_fast_trials %>%
  mutate(correct = case_when(trial_type == "prime_negative" & correct == 0 ~ 1,
                             trial_type == "prime_negative" & correct == 1 ~ 0,
                             TRUE ~ correct))

```
